# Action Definitions

Actions is the generic term for both `operations` and `functions`. The only difference between the two is that actions defined in an `operations` block have their implementations generated by Keel whereas actions defined in a `functions` block are implemented by the user in TypeScript.

### `<actionType> <actionName>([inputs...]) [actionBody]`

An action definition is an action type followed by the action name and the list of inputs that action takes in a set of parenthesis.

## Action Types

### `create`

Created a new record. Must accept all required fields that don’t have default values as inputs.

### `update`

Updates a single record. Must accept as inputs a unique field to look up the record and at least one field to update.

### `get`

Retrieves a single record. Must accept a unique field as input.

### `list`

Returns a list of records. May accept as inputs any number of non-unique fields to filter the results.

## Action Name

An action name must be _globally_ unique. This is because in both the case of GraphQL or RPC actions are top level and so if two models both defined an action with the same name they would clash.

## Action Inputs

Inputs to actions take the form `label: type`. `label` is the name of the field as it will appear in an API, and type is the type of that field. Inputs can then be used in expressions like `@set` and `@where` to define the behaviour of the action.

```graphql
model Person {
  fields {
    firstname Text
  }
  operations {
    get getPerson(id: ID) {
      @where(person.id == id)
    }
    create createPerson(firstname: Text) {
      @set(person.firstname = firstname)
    }
  }
}
```

### Short-form inputs

There is a short-form way of defining inputs where the input names correspond to a field name on the model. The following example is semantically exactly the same as the previous example, but is much more concise.

```graphql
model Person {
  fields {
    firstname Text
  }
  operations {
    get getPerson(id)
    create createPerson(firstname)
  }
}
```

The default behaviour of an input for `get` and `list` actions is to filter by those fields, and for `update` and `create` it is to set those fields.

### Optional inputs

Inputs can also be optional by adding the `?` suffix to the type, or in the short-form version the field name e.g. `create createPerson(firstname?)`. By being optional it means the field can be completely omitted from an API call. In certain cases making an input optional will result in a validation error, for example in a create action where the field has no default value.

### Relationships as inputs

The behaviour of fields that refer to a relationship when used as inputs depends on the type of the action.

For `get` actions a relationship input means you can lookup by the related model. This is only allowed if the relationship field is marked as `@unique`.

#### Example of relationship input in get

In this example the `getPersonByAddress` action would create an API that accepted an argument called `address` which would let you look up a person by the ID of their address.

```jsx
model Person {
  fields {
    address Address @unique
  }
  operations {
    get getPersonByAddress(address)
  }
}

model Address {

}
```

For `list` actions it is required to be explicit about which fields on the related model you wish to be able to filter by by using dot-notation e.g. `address.postcode`.

#### Example of relationship input in list

In this example it is possible to list orders by the price of the items linked to that order, so you could list all orders that contain items over a certain price.

```jsx
model Order {
  fields {
    items Item[]
  }
  operations {
    list listOrders(items.price)
  }
}

model Item {
  fields {
    price Number
  }
}
```

For `update` actions it is also required to be explicit about which fields on the related model you wish to update by using dot-notation e.g. `address.postcode`.

For `create` actions using a relationship field as an input means that object will be created.

## Action Body

Actions can optionally have a “body” (indicated by a pair of curly braces) which can contain attributes that change the behaviour of the action, for example adding a permission rule or an implicit database filter.

---
