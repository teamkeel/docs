---
sidebar_position: 3
---

# Schema reference

## Keywords

Keywords are always followed by a set of curly braces which are referred to as a “block”.

### `model <ModelName>`

Used to define a Model in the schema. The model name should be written in _UpperCamelCase_ and must be unique within all models defined in the schema.

```graphql
 model Author {

 }
```

### `fields`

Used to define the fields a Model contains. Only valid inside a `model` block.

```graphql
model Author {
  fields {
    name Text
  }
}
```

### `operations`

Used to define the auto-generated operations a Model has. Only valid inside a `model` block.

```graphql
model Author {
  fields {
    name Text
  }
  operations {
    create createAuthor(name)
  }
}
```

### `functions`

Used to define the custom functions that will be implemented for a Model. Only valid inside a `model` block.

```graphql
model Author {
  fields {
    name Text
  }
  functions {
    create createAuthor(name)
  }
}
```

### `api <ApiName>`

Used to define an API that the generated Keel application should expose. The API name should be written in UpperCamelCase and be unique within all API’s defined in the schema.

#### `models`

Used to define which Models should be included in an API. Only valid inside an `api` block.

```graphql
api Web {
  models {
    Author
    Book
  }
}
```

### `role <RoleName>`

Used to define a role in the schema. The role name must be written in _UpperCamelCase_ and must be unique within all roles defined in the schema. Role names are used in `@permission` rules.

#### `domains`

Used to define a list of domains that if matched against the current Identities email address should result in the Role being applied. Each domain must wrapped in double quotes to indicate it is a literal.

```graphql
role Staff {
  domains {
    "myorg.com"
    "anotherorg.com"
  }
}
```

#### `emails`

Used to define a set of email addresses that if matched against the current Identities email address should result in the Role being applied. Each email must wrapped in double quotes to indicate it is a literal.

```graphql
role Admin {
  emails {
    "harry@myorg.com"
    "sarah@myorg.com"
  }
}
```

---

## Action Definitions

Actions is the generic term for both `operations` and `functions`. The only difference between the two is that actions defined in an `operations` block have their implementations generated by Keel whereas actions defined in a `functions` block are implemented by the user in TypeScript.

#### `<actionType> <actionName>([inputs...]) [actionBody]`

An action definition is an action type followed by the action name and the list of inputs that action takes in a set of parenthesis.

### Action Types

#### `create`

Created a new record. Must accept all required fields that don’t have default values as inputs.

#### `update`

Updates a single record. Must accept as inputs a unique field to look up the record and at least one field to update.

#### `get`

Retrieves a single record. Must accept a unique field as input.

#### `list`

Returns a list of records. May accept as inputs any number of non-unique fields to filter the results.

### Action Name

An action name must be _globally_ unique. This is because in both the case of GraphQL or RPC actions are top level and so if two models both defined an action with the same name they would clash.

### Action Inputs

Inputs to actions take the form `label: type`. `label` is the name of the field as it will appear in an API, and type is the type of that field. Inputs can then be used in expressions like `@set` and `@where` to define the behaviour of the action.

```graphql
model Person {
  fields {
    firstname Text
  }
  operations {
    get getPerson(id: ID) {
      @where(person.id == id)
    }
    create createPerson(firstname: Text) {
      @set(person.firstname = firstname)
    }
  }
}
```

#### Short-form inputs

There is a short-form way of defining inputs where the input names correspond to a field name on the model. The following example is semantically exactly the same as the previous example, but is much more concise.

```graphql
model Person {
  fields {
    firstname Text
  }
  operations {
    get getPerson(id)
    create createPerson(firstname)
  }
}
```

The default behaviour of an input for `get` and `list` actions is to filter by those fields, and for `update` and `create` it is to set those fields.

#### Optional inputs

Inputs can also be optional by adding the `?` suffix to the type, or in the short-form version the field name e.g. `create createPerson(firstname?)`. By being optional it means the field can be completely omitted from an API call. In certain cases making an input optional will result in a validation error, for example in a create action where the field has no default value.

#### Relationships as inputs

The behaviour of fields that refer to a relationship when used as inputs depends on the type of the action.

For `get` actions a relationship input means you can lookup by the related model. This is only allowed if the relationship field is marked as `@unique`.

##### Example of relationship input in get

In this example the `getPersonByAddress` action would create an API that accepted an argument called `address` which would let you look up a person by the ID of their address.

```jsx
model Person {
  fields {
    address Address @unique
  }
  operations {
    get getPersonByAddress(address)
  }
}

model Address {

}
```

For `list` actions it is required to be explicit about which fields on the related model you wish to be able to filter by by using dot-notation e.g. `address.postcode`.

##### Example of relationship input in list

In this example it is possible to list orders by the price of the items linked to that order, so you could list all orders that contain items over a certain price.

```jsx
model Order {
  fields {
    items Item[]
  }
  operations {
    list listOrders(items.price)
  }
}

model Item {
  fields {
    price Number
  }
}
```

For `update` actions it is also required to be explicit about which fields on the related model you wish to update by using dot-notation e.g. `address.postcode`.

For `create` actions using a relationship field as an input means that object will be created.

### Action Body

Actions can optionally have a “body” (indicated by a pair of curly braces) which can contain attributes that change the behaviour of the action, for example adding a permission rule or an implicit database filter.

---

## Field Definitions

Fields are defined in the `fields` block inside a model and indicate what data that model contains.

#### `fieldName fieldType[modifier] [fieldBody]`

Field definitions start with the name of the field which must be written in lowerCamelCase, followed by the field type.

### Field Names

Field names must be unique with the parent model and written in _lowerCamelCase_. Every model has three built in fields - `id`, `createdAt` and `updatedAt` and so user-defined fields cannot use these names. Field names may only contain the characters `[a-zA-Z0-9]`.

### Field Types

A fields type must be one of the built-in Keel types or another user-defined model (as a relationship). A fields type is allowed to reference it’s parent model to create a self-relationship. For a list of built-in Keel field types see [this page](https://www.notion.so/Field-types-4766712d7c9049fea895a619641dcdbe).

### Repeated and Optional Fields

Field are by default required, meaning they cannot be null. To mark a field as being optional you can add a `?` at the end of the type, for example `Text?` is a text field that can be null.

Fields can also be marked as being repeated by adding `[]` to the end of the type, for example `Text[]` means a list (or array) of text values. Mostly this is useful for relationships between models to denote one-to-many or many-to-many relationships.

### Field Body

Fields can optionally have a “body” (indicated by a pair of curly braces) which can contain attributes that change the behaviour of the field, for example adding a unique constraint.

---

## Attributes

Attributes are used to define additional behaviour to a block. In any given block there will be some allowed attributes. If an attribute is used in a block that doesn’t support it then a validation error will be raised.

### `@unique`

Can be added to a field block to indicate the field has a unique constraint. Only valid for the field types `Text`, `Number`, `Boolean`, `Enum`, `ID`, and `Date`.

```graphql
model Book {
  fields {
    isbn Text @unique
  }
}
```

This attribute can also be used at the model level to create a unique constraint across multiple fields. When doing this the field names are passed as arguments to the attribute.

```graphql
model Book {
  fields {
    firstname Text
    lastname Text
  }

  @unique(firstname, lastname)
}
```

### `@default(expression)`

Can be used inside a field block to provide a default value for that field. The default value provided must match the type of the field.

```graphql
enum UserType {
  USER
  ADMIN
}

model User {
  fields {
    type UserType @default(UserType.USER)
  }
}
```

If no argument is provided then the default value depends on the field type.

| Field Type | Default Value |
| ---------- | ------------- |
| Text       | "”            |
| Number     | 0             |
| Date       | Current date  |
| Timestamp  | Current time  |
| Boolean    | false         |

The argument is an expression which means it can use `ctx` and the parent model.

##### Example using expressions in `@default`

```graphql
model User {
  fields {
    identity Identity {
      @default(ctx.identity)
    }
    firstname Text
    nickname Text {
      @default(user.firstName)
    }
  }
}
```

### `@permission(roles, expression, actions)`

Can be added to a model or action block define a permission rule that determines whether an action is allowed or not for the current Identity. If used at the model level `actions` must be provided, however if used in an action block (whether an operation or a function) then `actions` must not be provided. Both `role`s and `expression` can be provided by only one must pass for the action to be allowed.

`roles` must be a list of `Role` defined in the schema. It is optional if `expression` is provided.

`expression` must be a logical expression. The expression is evaluated at _runtime_ and as access to the current model and the context. See [Expressions](https://www.notion.so/Schema-Reference-2fd7afd4067b428e9ae7e2ee85787ac1) for more info. This argument is optional if `role` is provided.

`actions` must be a list of [action types](https://www.notion.so/Schema-Reference-2fd7afd4067b428e9ae7e2ee85787ac1) that this permission rule should apply to. Only provide this argument if using `@permission` at the model level.

##### Example of permission at model level

```graphql
model Author {
  @permission(
    role: Staff,
    expression: ctx.ipAddress in ["127.0.0.1"],
    actions: [create, get, update]
  )
}
```

##### Example of permission at action level

```graphql
model Post {
  fields {
    author Identity
    title Text
  }
  operations {
    update updatePost(title) {
      @permission(
        expression: post.author == ctx.identity
      )
    }
  }
}
```

### `@where(expression)`

Can be used inside an action definition to provide an implicit filter to the database query. Only valid inside `update`, `get`, and `list` actions. The provided expression must be a binary or logical expression.

```graphql
model Book {
  fields {
    genre Text
  }
  operations {
    list crimeBooks() {
      where(book.genre == "crime")
    }
  }
}
```

### `@set(expression)`

Can be used inside a `create` or `update` action to implicitly set a field on the model being created or updated. The provided expression must be an assignment expression.

```graphql
model Post {
  fields {
    createdBy Identity
    body Text
  }
  operations {
    create createPost(body) {
      @set(post.createdBy = ctx.identity)
    }
  }
}
```

### `@validate(expression)`

Can be used in any operation to provide additional validation. The expression has access to the model(s) being read/written, the inputs, and the context.

```graphql
model Task {
  fields {
    assignedTo Identity?
    startedAt Timestamp?
  }

  operations {
    update assignTask(id, assignedTo)
    update startTask() {
      // cannot start a task if it is not assigned to someone
      @validate(task.assignedTo != null)
      @set(task.startedAt = ctx.timestamp)
    }
  }
}
```

---

## Expressions

Expressions can be used as the argument to a number of attributes to provide runtime logic. Expressions always have access to two variables, the current model and the current context.

### Referencing the model

The current model is available in its _lowerCamelCased_ form, so if the model is called `FeaturedPost` then the expression can reference `featuredPost`. Any field on the model can be referenced using dot notation e.g. `modelName.fieldName`.

### Referencing the context

The current context, which in many cases can be thought of as the current request, is available as `ctx`. This object has the following fields:

- `identity` - a reference to the currently authenticated identity (can be null)
- `now` - the current timestamp

### Binary Expressions

A binary expression is an expression that evaluates to a boolean value, for example `A == B` or `A != B`. Supported operators are:

| Operator | Description                                                               | Example    |
| -------- | ------------------------------------------------------------------------- | ---------- |
| ==       | A equals B                                                                | A == B     |
| !=       | A does not equal B                                                        | A != B     |
| >        | A is greater than B                                                       | A > B      |
| >=       | A is greater than or equal to B                                           | A >= B     |
| <        | A is smaller than B                                                       | A < B      |
| <=       | A is smaller than or equal to B                                           | A <= B     |
| in       | B, which is a list of values, contains A, which is a single value         | A in B     |
| not in   | B, which is a list of values, does not contain A, which is a single value | A not in B |

### Logical Expressions

A logical expression is an expression that uses the operators `and` or `or`. Each side of the operator is either a binary expression or another logical expression. The following are all valid logical expressions:

- `A == B or A == C`
- `A != B and A not in C`
- `A in B or (A == C and A != D)`

### Assignment Expressions

An assignment expression is an expression that results in the left-hand side being updated based on the operator and right-hand side. Assignment expressions are only valid when passed to the `@set` attribute inside a `create` or `update` operation. A common use case will be setting a field on a model to the current identity performing the operation or to increment a counter.

```graphql
model Counter {
  fields {
    value Number
    lastIncrementedBy Identity
  }
  operations {
    update updateCounter(id) {
      @set(counter.value += 1)
      @set(counter.lastIncrementedBy = ctx.identity)
    }
  }
}
```

Supported operators for assignment expressions are:

| Operator | Description                 | Example |
| -------- | --------------------------- | ------- |
| =        | Updates A to the value of B | A = B   |
| +=       | Increments A by B           | A += B  |
| -=       | Decrements A by B           | A -= B  |

## Relationships

When a field uses another model as its type that creates a relationship being the two models. The type of relationship depends on whether the fields are marked as repeated on each side.

| Model A            | Model B      | Relationship Type (from perspective of Model A) |
| ------------------ | ------------ | ----------------------------------------------- |
| ModelB[]           | No reference | One-to-many                                     |
| ModelB[]           | ModelA       | One-to-many                                     |
| ModelB[]           | ModelA[]     | Many-to-many                                    |
| ModelB { @unique } | No reference | One-to-one                                      |
| ModelB             | No reference | Many-to-one                                     |
| ModelB             | ModelA       | Invalid                                         |
| ModelB             | ModelA[]     | One-to-many                                     |

Models can reference one another via standard relational concepts such as has_one, has_many, belongs_to.

##### Example of has_many / belongs to:

```graphql
model Post {
  fields {
    title Text
		author Author
  }
}

model Author {
  fields {
    name Text
    posts Post[]
  }
}
```

##### Example of many to many relationship

```graphql
model Project {
  fields {
    title Text
		author Author
    assignments ProjectAssignment[]
  }
}

@join_table
model ProjectAssignment {
  fields {
    project Project
    employee Employee
  }
}

model Employee {
  fields {
    firstName Text
    lastName Text
    assignments ProjectAssignment[]
  }
}
```
