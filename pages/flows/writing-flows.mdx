import { Callout } from "@core/callout"

# Writing flows

The [introduction page](/flows) demonstrated how to write a simple flow with a function step, a UI step, and some logic in between. Let us now dig into a bit more details about the important mechanics of how flows execute.

## Flow architecture

A flow is made up of the following discernable parts:

 - **Inputs:** Values passed into the body of the flow implementation
 - **Body:** The implementation of the flow in TypeScript, containing code and any number of steps
 - **Steps:** Durable units of work defined in TypeScript

A step can either a:

 - **Function step:** Executes background logic which needs to run in a durable way
 - **UI step:** Presents interfaces to a user and waits on them for input

As mentioned, a flow's body can be made up of some code and any number of *steps*.  In fact, if you don't have code which is needed to execute in a durable way and if you don't require any user input, then steps aren't necessary and your flow body itself can contain all the code logic.

## Flow lifecycle

It's important to know that a single instance of a flow can actually be executed many times. However, each step in the flow's body can only ever be successfully executed a single time. Once a step has successfully executed, the data it returns data will be persisted. When the instance of the flow happens to execute again, andf that same step is re-encountered, then its previously returned data will be substituted in place of the step executing again. This behaviour applies to both function and UI steps.

You may be wondering why a flow body might be executed multiple times? This is intentional, and it happens whenever a new function or UI step is encountered; the entire flow will execute from the top all the way until that encountered step and including that step, and then it will exit the flow and start again from the beginning (assuming it didn't reach the end of the flow). A step may take some time to complete (for example, a UI step needs to wait on user input), so with this knowledge you can design your flow in such a way that it is always dealing with fresh and relevant data.

For example, consider this flow that confirms the delivery address of an order and then dispatches it to the courier company:

```ts
export default DispatchOrder({}, async (ctx, inputs) => {
    // This will execute with every pass of the flow because we always want to get the latest data.
    const order = await models.order.findOne({ id: inputs.orderId });
    if (order.status == OrderStatus.Shipped) {
        throw new Error("order has already been shipped");
    }

    // Present the order address to the user for correcting. This must only ever happen once.
    const { address } = await ctx.ui.page("confirm address", {
        title: "Address confirmation",
        stage: "selectOrder",
        description: "Please update the delivery address where necessary",
        content: [
            ctx.ui.input.text("address", {
                label: "Select order",
                optional: false,
                placeholder: order.deliveryAddress,
            }),
        ],
    });

    // Submit this order to the courier company and retrieve the tracking number. This must only ever happen once.
    const trackingNumber = await ctx.step("submit to courier", async () => {
        return submitToCourier(order);
    });

    // Now update the order accordingly.
    await models.order.update(
        { id: inputs.orderId },
        { 
            trackingNumber: trackingNumber,
            deliveryAddress: address,
            status: DeliveryStatus.Shipped
        }
    );
});
```

## Inputs

A flow can be defined to accept inputs. Flows support all of the standard Keel types and the inputs can be defined as optional or required. These inputs are captured once, right when a new instance of a flow is started, and are then passed to your flow implementation as arguments.

For example, a flow that processes an order might be defined in the schema as follows.

```keel
flow ProcessOrder {
  inputs {
    orderId ID
    priority Boolean
  }
  @permission(roles: [Manager])
}
```

These values are captured when starting and flow, and are passed to the body of the flow in `inputs`.

```ts
export default ProcessOrder({}, async (ctx, inputs) => {
    // The inputs are available throughout the flow
    const order = await models.order.findOne({ id: inputs.orderId });
    
    if (inputs.priority) {
        // Handle priority orders differently
    }
    
    // Continue with normal processing...
});
```

<Callout >
  After defining your flow in the schema, running `keel generate` at the root of your project will scaffold out your new flow in the `/flows` directory.
</Callout>

## Flow context

As already demonstrated, the `ctx` argument passed into the flow body is used to define function and UI steps, but it also passes in other useful information to the flow, as highlighted in the table below.

| Property | Description | Example |
| :------- | :========== | :====== |
| `step` | Defines a function step | `await ctx.step("my step", async () => { ... }`); |
| `page` | Defines a UI step | `await ctx.page({ ... }); |
| `identity` | The identity executing the flow | `ctx.identity.email` |
| `env` | Your [environment variables](/envvars) | `ctx.env.STRIPE_CUSTOMER_ID` |
| `secrets` | Your [environment secrets](/secrets) | `ctx.secrets.STRIPE_API_KEY` |

## Stages

TODO

## Failures

If an exception is thrown in the body of a flow, then the entire flow will stop and its status will be set to `FAILED`. This is different from function step failures, which will trigger retry attempts as described in the [function steps documentation](/flows/functions#retry-logic).

## Duration of execution

Executing a flow has a duration threshold of 15 minutes. However, this can be easily misunderstood. Because a flow is re-executed from the beginning for each step encountered and because each function step's logic is actually executed in independent flow executions, the total runtime of a flow has no real limit. This means you can build flows that take days or weeks to complete, as long as each individual step execution stays within its timeout limits.

## Concurrency

At present we do not support running steps concurrently, so please use `async` when calling on steps, i.e. when `async ctx.step` or `async ctx.page`. This ensures that steps are executed in the correct sequence and that their results are properly handled.

For more information about building robust flows, check out our [best practices](/flows/best-practices) guide.
