# Functions SDK 


## Introduction

The Keel JS Functions SDK is a powerful toolkit for developing serverless functions that interact with your Keel application's data models and business logic. It provides:

- **Typed Function Wrappers**: Auto-generated functions based on your schema.
- **Models API**: Access and manipulate your data models with ease.
- **Database API**: Execute raw SQL queries when needed.
- **Permissions**: Enforce access control within your functions.
- **Context API**: Access request-specific information like the current user.

The SDK bridges the gap between your Keel schema—defined using the Keel DSL—and your serverless functions, ensuring type safety and consistency across your application.

---

## Typed Function Wrappers

Typed function wrappers are generated based on your Keel schema. They provide strongly-typed interfaces for your functions, ensuring inputs and outputs match your schema definitions.

### Custom Functions

Custom functions are arbitrary functions you define in your schema using the `read` or `write` action types. They allow you to execute custom logic that doesn't fit into standard CRUD operations.

#### Defining a Custom Function in Schema

```keel
model Person {
    fields {
        name Text
        height Number
    }

    actions {
        write createPerson(name, height) returns (PersonResponse)
    }
}
```

#### Implementing a Custom Function

```typescript
import { CreatePerson } from '@teamkeel/sdk';

export default CreatePerson(async (ctx, inputs) => {
  // Your custom logic here
  const person = await ctx.models.person.create({
    name: inputs.name,
    height: inputs.height,
  });

  return {
    id: person.id,
    name: person.name,
    height: person.height,
  };
});
```

- **`CreatePerson`**: The function wrapper generated based on your schema.
- **`ctx`**: The context object providing access to models, permissions, and more.
- **`inputs`**: The inputs defined in your schema.

### Function Hooks

Function hooks apply to standard CRUD actions (`get`, `list`, `create`, `update`, `delete`) and allow you to modify or extend the behavior of these actions at different stages.

#### Available Hooks

- **`beforeQuery`**: Modify the query before it is executed.
- **`afterQuery`**: Modify the result after the query is executed.
- **`beforeWrite`**: Modify inputs before data is written to the database.
- **`afterWrite`**: Modify the result after data is written to the database.

#### Implementing a Function with Hooks

```typescript
import { UpdatePerson, UpdatePersonHooks } from '@teamkeel/sdk';

const hooks: UpdatePersonHooks = {
  beforeWrite: async (ctx, inputs, values, record) => {
    // Modify values before updating the record
    if (values.height && values.height < 0) {
      throw new Error('Height cannot be negative');
    }
    return values;
  },
  afterWrite: async (ctx, inputs, data) => {
    // Perform actions after the record is updated
    await ctx.models.auditLog.create({
      action: 'update',
      model: 'Person',
      modelId: data.id,
    });
  },
};

export default UpdatePerson(hooks);
```

---

## Models API

The Models API provides a set of methods to interact with your data models. The methods are standard across models, but the actual models and their fields are generated based on your schema.

### Standard Model Methods

- **`findOne(query)`**: Retrieve a single record matching the query.
- **`findMany(query)`**: Retrieve multiple records matching the query.
- **`create(data)`**: Create a new record.
- **`update(query, data)`**: Update records matching the query.
- **`delete(query)`**: Delete records matching the query.

#### Example Usage

```typescript
const person = await ctx.models.person.findOne({ id: '1234' });

await ctx.models.person.update({ id: '1234' }, { height: 180 });

await ctx.models.person.delete({ id: '1234' });
```

### Query Building

Queries can be constructed using a fluent API to build complex conditions.

```typescript
const tallPeople = await ctx.models.person.findMany({
  where: {
    height: {
      gt: 170,
    },
  },
  orderBy: {
    height: 'desc',
  },
  limit: 10,
});
```

---

## Database API

The Database API allows you to execute raw SQL queries using [Kysely](https://koskimas.github.io/kysely/) as the underlying query builder.

```typescript
const result = await ctx.db
  .selectFrom('person')
  .select(['id', 'name'])
  .where('height', '>', 170)
  .execute();
```

- **`ctx.db`**: The Kysely database instance.
- Supports full TypeScript typing based on your schema.

---

## Permissions

The Permissions module helps enforce access control within your functions. You can check permissions and explicitly allow or deny access.

### Available Methods

- **`permissions.allow()`**: Explicitly allow the action.
- **`permissions.deny(reason)`**: Deny the action with an optional reason.
- **`permissions.assert(condition, reason)`**: Allow if the condition is true, otherwise deny with the provided reason.

#### Example Usage

```typescript
import { permissions } from '@teamkeel/sdk';

export default UpdatePerson(async (ctx, inputs) => {
  // Deny if the user is not an admin
  if (!ctx.identity.roles.includes('Admin')) {
    permissions.deny('Only admins can update a person');
  }

  // Alternatively, use assert
  permissions.assert(
    ctx.identity.roles.includes('Admin'),
    'Only admins can update a person'
  );

  // Proceed with the update
  const person = await ctx.models.person.update(
    { id: inputs.id },
    { name: inputs.name }
  );

  return person;
});
```

---

## Context API

The Context API provides access to the request-specific context, including the authenticated user's identity, request headers, and more.

### Properties

- **`ctx.identity`**: The authenticated user's identity.
- **`ctx.env`**: The environment variables.
- **`ctx.secrets`**: The project secrets.
- **`ctx.now`**: The time of the request.

Actions have access to the following properties:
- **`ctx.isAuthenticated`**: Whether the request is authenticated.
- **`ctx.headers`**: Read only request headers.
- **`ctx.response`**: The response object which can be used to set the response status code and headers.

#### Example

```typescript
export default Redirect(async (ctx) => {
  
  ctx.response.headers.set("Location", "https://example.com/new");
  ctx.response.status = 302

});
```

```typescript
export default GetSecretData(async (ctx) => {
  if (!ctx.identity) {
    permissions.deny('Authentication required');
  }

  // Use ctx.models or ctx.db to access data
});
```

---

## Examples

### Custom Function Example

#### Schema Definition

```keel
model Report {
    fields {
        title Text
        content Text
        author User
    }

    actions {
        write createReport(title, content, author.id) returns (ReportResponse)
    }
}
```

#### Function Implementation

```typescript
import { CreateReport } from '@teamkeel/sdk';

export default CreateReport(async (ctx, inputs) => {
  const report = await ctx.models.report.create({
    title: inputs.title,
    content: inputs.content,
    authorId: inputs.author.id,
  });

  return {
    id: report.id,
    title: report.title,
    content: report.content,
  };
});
```

### Model API Usage Example

```typescript
const recentReports = await ctx.models.report.findMany({
  where: {
    createdAt: {
      gt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days
    },
  },
  include: {
    author: true,
  },
  orderBy: {
    createdAt: 'desc',
  },
  limit: 5,
});
```

### Permission Control Example

```typescript
export default UpdateReport(async (ctx, inputs) => {
  const report = await ctx.models.report.findOne({ id: inputs.id });

  // Ensure the current user is the author
  permissions.assert(
    ctx.identity.id === report.authorId,
    'You can only update your own reports'
  );

  // Proceed with the update
  const updatedReport = await ctx.models.report.update(
    { id: inputs.id },
    { content: inputs.content }
  );

  return updatedReport;
});
```

